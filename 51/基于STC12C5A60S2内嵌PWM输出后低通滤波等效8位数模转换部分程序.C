//PWM后低通滤波等效数模转换,SW1设PWM数字量N,ON为0,OFF为1,SW6拨到PWM,测T1、T6间的电压
//{0,CL}中的值<{EPCnL,CCAPnL},输出低电平;{0,CL}中的值>={EPCnL,CCAPnL},输出高电平;
//当CL由FF变为00溢出时,{EPCnH,CCAPnH}内容装载到{EPCnL,CCAPnL}中,实现无干扰地更新PWM;
//设EPCnH=0,数字量N送CCAPnH:N=0,全部输出为高电平;N=1,只有CL=0时输出为低电平,其它时候
//输出为高电平;......;N=0xff,CL<0xff时输出均为低电平,只有CL=0xff时输出为高电平;
//低通滤波输出平均值,VPWMo=((256-N)/256)Vh+(N/256)Vl,Vh、Vl分别是PWM的高电平和低电平
//设Vl=0.000V,Vh=5.000V,则有VPWMo=((256-N)/256)5
//设SW6拨到PWM,VT1=-((R22/R20)(-5)+(R22/R21)VPWMo)
//代入参数,VT1=(220K/100K)5-(220K/50K)((256-N)/256)5=11[(2N-256)/256]
//讨论:N=0,VT1=-11.0V;N=128,VT1=0.0V;N=255,VT1=10.914V;理论上与8位D/A一样,实际有误差
//3#液晶板PWM的实验数据：N=0,VT1=-11.244V;N=128,VT1=-0.082V;N=255,VT1=10.938V
//3#液晶板DA的实验数据：N=0,VT1=-11.142V;N=128,VT1=-0.1368V;N=255,VT1=10.788V
#include <STC12C5A60S2.H>       //包含头文件STC12C5A60S2.H
#include <absacc.h>             //包含头文件absacc.h
#define D_port XBYTE [0x7FFF]   //数码管段码锁存器端口地址，A15为线选地址
#define B_port XBYTE [0xBFFF]   //数码管位码锁存器端口地址，A14为线选地址
typedef unsigned char u8;       //无符号字符型变量新表示方法定义
typedef unsigned int u16;       //无符号整型变量新表示方法定义
u8   r_kT,Ax;                   //PWM数据暂存量和中间量定义
u8   buf[8];                    //显示缓冲区定义
char m_kT;                      //PWM后滤波输出电压的10倍,-110～110,对应-11.0～11.0V
u16  temp1;                     //计算时的中间变量1
int  temp2;                     //计算时的中间变量2
float VT1;                      //PWM后滤波输出电压的10倍变量定义-110.0～110.0V
u8   M=0;                       //扫描显示位计数变量定义
u8 code Stab[16]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,
                  0x7c,0x39,0x5e,0x79,0x71};//0～F的共阴段码表 
u8 code Btab[8]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};//共阴位码表
/*************PWM初始化*************/
void  PWM_init(void)            //硬件二阶RC低通Tao=1ms>>0.0463ms=0.5*(1/10.8KHz)
{ CMOD=0x8a;                    //Fosc/4,fPWM=Fosc/4/256=10.8KHz,不准中断
  CCON=0x00;                    //00000000B控制,关闭PCA计数,CF\CCF1\CCF0均清0
  CL=0x00;                      //PCA计数器低8位清0
  CH=0x00;                      //PCA计数器高8位清0
  CCAPM0=0x42;                  //8位PWM无中断,允许比较器功能,P1.3做PWMO输出,禁止中断
  PCA_PWM0=0x00;                //最低2位EPC0H和EPC0L均设置为0
  CCAP0H=0x80;                  //预送PWM为50%的占空比
  CCAP0L=0x80;                  //预送PWM为50%的占空比
  CR=1;                         //允许PCA计数器工作
}
/***********T0T1初始化***********/
void  T0T1_init(void)           //8个数码管,每个显示时间为扫描显示周期的1/8
{ TMOD=0x21;                    //T0为16位定时、T1为8位自动重装定时
  SCON=0x40;                    //8位UART,波特率可变(2^1*T1溢出率/32)
  PCON=0x80;                    //使能波特率倍速位SMOD
  TH0=0xfb;                     //高字节,DA刷新周期10ms的时间常数fb80H
  TL0=0x80;                     //低字节,(65536-fb80H)/(11.0592/12)=1250微秒
  TH1=0xfd;                     //T1定时值,(2^SMOD)*307200/32=19200bps
  TL1=0xfd;                     //波特率=2*307200/32=19200bps
  EA=1;                         //允许中断
  ET0=1;                        //允许T0中断
  TR0=1;                        //启动T0定时
  TR1=1;                        //启动T1定时
}
/****DA数据的显示段码信息更新****/
void  disp_g(void)              //DA数据的显示段码信息更新
{ buf[7]=0x00;                  //符号位送正号段码
  buf[4]=0x76;                  //后缀位送十六进制后缀H的段码
  Ax=r_kT&0x0f;                 //取要显示的物理量
  buf[5]=Stab[Ax];              //8位DA数据的低4位对应十六进制数段码
  Ax=(r_kT&0xf0)>>4;            //取要显示的物理量
  buf[6]=Stab[Ax];              //8位DA数据的高4位对应十六进制数段码
}
void  disp_f(void)              //DA输出电压理论值的显示段码信息更新
{ if(m_kT<0)                    //如果是负数
  { Ax=-m_kT;                   //取绝对值
    buf[3]=0x40;                //符号位送负号段码
  }
  else                          //否则就是正数
  { Ax=m_kT;                    //取要显示的物理量
    buf[3]=0x00;                //符号位送正号段码
  }
  buf[0]=Stab[Ax%10];           //电压小数位段码信息更新
  buf[1]=Stab[Ax/10%10]|0x80;   //电压个位段码携小数点信息更新
  buf[2]=Stab[Ax/100];          //电压十位段码信息更新
}
/*************主程序*************/
void  main(void)
{ PWM_init();                   //PWM初始化程序
  T0T1_init();                  //T0、T1初始化程序(11.0592MHz)
  do
  { if(M>7)                     //8数码管全显了,扫描显示周期到,该DA数据刷新
    { r_kT=P1&0xc7;             //读入拨码开关高2位和低3位的值
      r_kT+=(P3&0x38);          //合并拨码开关中间3位的值
      CCAP0H=r_kT;              //0输出全高;128输出128个高(128个低);255仅输出1个高(255个低)
      temp1=(u16)r_kT<<1;       //计算2N,     VPWMo=((256-N)/256)5
      temp2=(int)temp1;         //            VT1=-((R22/R20)(-5)+(R22/R21)VPWMo)
      temp2-=256;               //计算2N-256,      =(220K/100K)5-(220K/50K)((256-N)/256)5
      VT1=(float)temp2*0.4296875;//计算(2N-256)(110/256), =11[(2N-256)/256],实际求10倍的VT1
      m_kT=(char)VT1;           //则N=0,VT1=-11.0V;N=128,VT1=0.0V;N=255,VT1=10.914V
      SBUF=r_kT;                //发送给定值
      disp_g();                 //DA数据的显示段码信息更新
      disp_f();                 //DA输出电压理论值的显示段码信息更新
      M=0;                      //扫描显示位计数器清0
    }
  }while(1);
}
/*********T0中断服务程序*********/
void t0(void) interrupt 1 using 1//1.25ms中断1次，每次均要进行显示处理
{ TH0=0xfb;                     //T0时间常数高字节重装
  TL0=0x80;                     //T0时间常数低字节重装
  B_port=0xff;                  //关闭显示
  D_port=buf[M];                //对应数码管的段码值送给段码端口U2
  B_port=Btab[M];               //对应数码管的位码值送给位码端口U3
  M++;                          //修改到下一次要显示的数码管
}