//2018/12/27  备注学习

//8位模数转换,ADC0809的0通道中断式A/D转换,T8接T3,测T8、T6间的电压
//网络标号SW8设为ON表示在AD值基础上迭加噪声
char code rand[256]={-4,-4,-1,-4,-1,-3, 0,-3, 1, 4,  //随机噪声，-4~+4范围
                     -2,-1,-4, 1, 0,-4,-3, 2, 1, 2,
                      2, 4,-3,-1, 4, 3, 3, 2, 0, 0,
                      1, 0, 0, 1,-3,-1,-3, 1, 0, 0,
                      0,-1, 3,-2,-3,-1, 1,-3, 0, 1,
                      1,-4, 2,-2, 0,-1,-1, 0, 0,-2,
                     -3, 2,-2,-1,-1,-2,-1,-4, 0, 4,
                     -4,-1,-4,-4,-2, 4,-1,-1,-3,-3,
                     -3,-2, 2, 3, 3, 2, 0, 0,-4,-3,
                      0, 0, 0,-2,-3, 1, 1, 3, 3,-4,
                      0, 0, 1, 2,-2,-3,-2,-1, 0,-3,
                      1,-4, 4,-3, 2, 1, 1, 2, 0, 0,
                     -3,-2, 3, 2, 1, 4, 4, 4, 2, 0,
                     -2, 1,-2, 1, 0,-3, 0,-1, 2,-1,
                      1,-3,-3,-1, 3, 1, 1, 1, 1, 1,
                      1, 4,-1, 0,-1, 4,-4, 3, 0,-2,
                      0, 0, 1, 1, 0, 2,-1,-4, 3, 1,
                      4, 0,-1, 3, 1, 0, 1,-2,-2, 3,
                     -4, 4, 1,-4, 3, 2, 1, 3, 0,-2,
                      1,-2,-1, 2, 4, 3,-2,-1, 3,-1,
                     -1, 3,-3,-3,-2,-3, 1, 4,-2,-4,
                      4,-2,-3,-4, 0, 3, 3,-2, 1, 3,
                      1,-4, 0, 2, 3, 2, 1, 0, 4, 4,
                     -4,-1, 2,-4, 1,-1,-3,-1,-2, 0,
                     -4, 4,-4,-4,-2, 0,-1,-3, 0,-3,
                     -3,-1,-4, 0, 0,-3,};
					 
//网络标号SW6设为ON表示要一阶低通滤波；SW3、SW2和SW1选择RC时间常数
//SW3_SW2_SW1      Tao(s)     R(欧姆)   C(法拉)
// on  on  on      0.01        100      0.0001
// on  on off      0.02        200      0.0001
// on off  on      0.04        400      0.0001
// on off off      0.08        800      0.0001
//off  on  on      0.1        1000      0.0001
//off  on off      0.2        2000      0.0001
//off off  on      0.3        3000      0.0001
//off off off      0.4        4000      0.0001
//利用拨码改变时间常数
float code  Rtable[8]={100,200,400,800,1000,2000,3000,4000};    //电阻表(欧姆)
float code  Ctable[8]={0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,0.0001};//电容表(法拉)
#include <reg52.h>              //包含头文件reg52.h
#include <absacc.h>             //包含头文件absacc.h
#define D_port XBYTE [0x7FFF]   //数码管段码锁存器U2端口地址,A15为线选地址
#define B_port XBYTE [0xBFFF]   //数码管位码锁存器U3端口地址,A14为线选地址
#define AD0    XBYTE [0xF0FF]   //U5通道0的端口地址,A11为线选地址,A10A9A8选0通道
#define DA    XBYTE [0xEFFF]    //外部DA转换数据输入端口地址
typedef unsigned char u8;       //字符型变量新表示方法定义
typedef unsigned int u16;       //整型变量新表示方法定义
//标度变换相关常量   需提前做实验得出，不取最大最小值，可取临界最大最小值
#define A0  ____                //??#实验板的实验4 ADC0通道下限值  
#define Am  ____                //??#实验板的实验4 ADC0通道上限值
#define N0  0x20                //??#实验板的实验4的0通道下限值对应数字量
#define Nm  0xe0                //??#实验板的实验4的0通道上限值对应数字量
//标度反变换相关常量
#define Any ____                //??#实验板的实验2 DAC数据下限值
#define Apy ____                //??#实验板的实验2 DAC数据上限值
#define Nny 0x20                //??#实验板的实验2数据下限值对应数字量
#define Npy 0xe0                //??#实验板的实验2数据上限值对应数字量

#define T  0.01                 //采样周期10ms      更改采用（定时器）周期时，此处记得更改

sbit    SW6 = P3^5;             //使用一阶RC低通滤波的开关输入位定义(置ON时要滤波)
sbit    SW8 = P1^7;             //迭加噪声的开关输入位定义(置ON时迭加)
bit     new_cycle_flag=0;       //有新采样数据位标志定义(1是有新采样数据)及初始化
u8      r_kT,Ax;                //AD转换结果和中间变量定义
char    buf[8],m_kT;            //显示缓冲数组和输入理论电压的10倍整数部分定义
float   Ax1,a1,b1;              //采样电压及其标度变换的斜率和截距定义
u16     temp1;                  //中间量定义
float   Ay,Ay_1=0;              //滤波当前输出、滤波上次输出定义
float   alfa,yi_alfa;           //滤波系数定义
float   a2,n0;                  //输出电压标度发变换的斜率和截距定义
float   Ny;                     //计算的DA数字量
u8      DA_kT;                  //实际DA操作的数字量
u8      J=0;                    //查噪声表计数变量定义
u8      M=0;                    //扫描显示位计数变量定义及初始化
u8 code Stab[16]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,
                  0x7c,0x39,0x5e,0x79,0x71};//0～F的共阴段码表 
u8 code Btab[8]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};//共阴位码表
/**********标度变换初始化**********/
void Scaleconversion_value_init(void)
{ Ax1 = Am , Ay=Nm ;
  Ax1 -= A0 , Ay -= N0 ;
  a1 = Ax1  / Ay ;        //斜率a1
  b1 = -a1 ;
  b1 *= N0 ;
  b1 += A0 ;              //截距b1
  //标度反变换初始化
  Ay = Npy , Ax1 = Apy ;
  Ay -= Nny , Ax1 -= Any ;
  a2 = Ay / Ax1 ;         //斜率a2
  n0 = Any ;
  n0 *= -a2 ;
  n0 += Nny ;             //截距n0
}
/***********T0T1初始化***********/
void  T0T1_init(void)           //8个数码管,每个显示时间为采样周期的1/8
{ TMOD=0x21;                    //T0为16位定时、T1为8位自动重装定时
  SCON=0x40;                    //8位UART,波特率可变(2^1*T1溢出率/32)
  PCON=0x80;                    //使能波特率倍速位SMOD
  TH0=0xfb;                     //高字节,AD采样周期10ms的时间常数fb80H
  TL0=0x80;                     //低字节,(65536-fb80H)/(11.0592/12)=1250微秒
  TH1=0xfd;                     //T1定时值,(2^SMOD)*307200/32=19200bps
  TL1=0xfd;                     //波特率=2*307200/32=19200bps
  EA=1;                         //允许中断
  ES=0;                         //禁止串行发送结束中断
  ET0=1;                        //允许T0中断
  TR0=1;                        //启动T0定时
  TR1=1;                        //启动T1定时
}

/*************一阶低通滤波算法*************/
void  filter_1(void)
{ Ay=alfa*Ax1;                  //公式(6-7)
  Ay+=yi_alfa*Ay_1;             //滤波计算，2次乘法，1次加法
  Ay_1=Ay;                      //迭代，为下一次运算做准备
}


/****AD数据的显示段码信息更新****/
void  disp_g(void)              //AD输入电压理论值的显示段码信息更新
{ if(m_kT<0)                    //如果是负数
  { Ax=-m_kT;                   //取绝对值
    buf[7]=0x40;                //符号位送负号段码
  }
  else                          //否则就是正数
  { Ax=m_kT;                    //取要显示的物理量
    buf[7]=0x00;                //符号位送正号段码
  }
  buf[4]=Stab[Ax%10];           //电压小数位段码信息更新
  buf[5]=Stab[Ax/10%10]|0x80;   //电压个位段码携小数点信息更新
  buf[6]=Stab[Ax/100];          //电压十位段码信息更新
}
void  disp_f(void)              //AD数据的显示段码信息更新
{ buf[0]=0x76;                  //后缀位送十六进制后缀H的段码
  Ax=r_kT&0x0f;                 //取要显示的物理量
  buf[1]=Stab[Ax];              //8位AD数据的低4位对应十六进制数段码
  Ax=(r_kT&0xf0)>>4;            //取要显示的物理量
  buf[2]=Stab[Ax];              //8位AD数据的高4位对应十六进制数段码
  buf[3]=0x00;                  //符号位送正号段码
}
/*************主程序*************/
void  main(void)
{ 
  //通过拨码查表计算时间常数    放在程序开头的缺点：每改变一次都得按复位键
  yi_alfa=Rtable[P1&0x07];      //查电阻表
  yi_alfa*=Ctable[P1&0x07];     //查电容表，求得时间常数
  yi_alfa+=T;                   //求分母
  alfa=T/yi_alfa;               //求公式(6-7)中的alfa
  yi_alfa=1.0-alfa;             //求公式(6-7)中的（1-alfa）
  Ay_1=0.0;                     //初始化     一开始上次误差设为0
  
  Scaleconversion_value_init(); //标度变换初始化，计算采样0通道的斜率a1和截距b1
  T0T1_init();                  //T0、T1初始化程序(11.0592MHz)
  IT0=1;                        //外部中断引脚INT0以下降沿方式触发中断请求
  EX0=1;                        //允许外部INT0申请中断
  do
  { if(new_cycle_flag==1)       //有新数据,Vs1=-(R5/R4)VT8=-(20K/100K)VT8=-0.2VT8
    { Ax1=(float)r_kT;          //
      J+=1;                     //查噪声表的计数器增1
      if(SW8==0)Ax1+=(float)rand[J];//要迭加噪声，根据经验，结果不会超出0~255的范围，直接加
      r_kT=(u8)Ax1;             //为了显示和通信而需暂存
      Ax1*=a1;                  //标度变换的乘法
      Ax1+=b1;                  //标度变换的加法        完成标度变换   经过标度变换，则无需再根据调理电路公式计算而可以直接得出实际采集电压值，因为前面的计算常量已是由公式计算而来
	  
      Ay=Ax1;                   //预想DA输出电压就是采样电压      因此不需要接线来进行反馈，输出可以直接跟踪给定
	  
      if(SW6==0) filter_1();    //要一阶RC低通滤波，调用滤波函数，DA输出电压改为滤波后输出电压
	  
      Ny = a2*Ay;               //标度反变换的乘法
      Ny+=n0;                   //标度反变换的加法
	  //限幅
      if(Ny>254.5)    DA_kT=255;//DA输出的修正值超大处理，考虑四舍五入
      else if(Ny<0.5) DA_kT=0;  //DA输出的修正值为负处理，考虑四舍五入
      else            DA_kT=(u8)(Ny+0.5);//DA输出的修正值适合DA输出的处理，考虑四舍五入
      DA=DA_kT ;                //DA输出(可能是AD值滤波后修正输出、也可能只是AD值修正后输出)
	  
      m_kT=(char)(10.0*Ax1);    //理论显示数字量部分m_kT=10*Ax1
	  
	  //先发送给定值，然后开启串口中断，后面就可以发反馈值
      TI=0;                     //清除发送结束状态标志
      ES=1;                     //允许串行发送结束中断
      SBUF=r_kT;                //发送转换结果
	  
      disp_g();                 //AD输入电压理论值的显示段码信息更新
      disp_f();                 //AD数据的显示段码信息更新
      new_cycle_flag=0;         //新采样数据标志清0
    }
  }while(1);
}
/***********T0中断服务程序***********/
void t0(void) interrupt 1 using 1//1.25ms中断1次，每次均要进行显示处理
{ TH0=0xfb;                     //T0时间常数高字节重装
  TL0=0x80;                     //T0时间常数低字节重装
  if(M==8)                      //10ms到了吗？因为1.25ms*8=10ms
  { AD0=0x00;                   //到了10ms，启动0通道AD转换
    M=0;                        //M清0
  }
  B_port=0xff;                  //关闭显示
  D_port=buf[M];                //对应数码管的段码值送给段码端口U2
  B_port=Btab[M];               //对应数码管的位码值送给位码端口U3
  M++;                          //修改到下一次要显示的数码管
}
/********INT0中断服务程序********/
void int0(void) interrupt 0 using 2 //U5的EOC变1,U6C取非后变0,申请中断
{ r_kT=AD0;                     //读取AD结果
  new_cycle_flag=1;             //置有新采样数据标志
}
/*********TXD中断服务程序*********/
void txd(void) interrupt 4 using 3 //每10ms需发送2字节，第2字节靠串行中断完成
{ 
  TI=0;                         //清除发送结束状态标志
  ES=0;                         //发送到最后1个字节，禁止发送结束中断
  SBUF=DA_kT;                   //发送报文第2字节，DA值               发送反馈值  等待下一次中断
}